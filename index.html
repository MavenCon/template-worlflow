<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Maven 仓库浏览器</title>
</head>
<body>
<h1>Maven 仓库浏览器</h1>
<div id="breadcrumb" class="breadcrumb">
	<!-- 面包屑导航将由JavaScript动态生成 -->
</div>
<div id="content">
	<div class="loading">加载中...</div>
</div>

<script>
	// 全局变量，存储当前路径
	let currentPath = '';

	// 页面加载完成后执行
	window.onload = function () {
		// 获取并处理URL中的路径参数
		const urlParams = new URLSearchParams(window.location.search);
		const path = urlParams.get('path') || '';
		navigate(path);

		// 添加浏览器历史导航支持
		window.onpopstate = function (event) {
			if (event.state && event.state.path !== undefined) {
				navigateWithoutHistory(event.state.path);
			} else {
				navigateWithoutHistory('');
			}
		};
	};

	// 导航到指定路径 - 添加到浏览器历史
	function navigate(path) {
		// 规范化路径格式
		path = normalizePath(path);
		history.pushState({path: path}, '', path ? `?path=${encodeURIComponent(path)}` : '');
		navigateWithoutHistory(path);
	}

	// 不修改浏览历史的导航函数
	function navigateWithoutHistory(path) {
		// 规范化路径格式
		path = normalizePath(path);
		currentPath = path;
		updateBreadcrumbs();
		listDirectory(path);
	}

	// 规范化路径格式，确保路径格式一致
	function normalizePath(path) {
		// 移除开头和结尾的斜杠
		path = path.replace(/^\/+|\/+$/g, '');
		// 统一处理多个连续斜杠为单个斜杠
		path = path.replace(/\/+/g, '/');
		return path;
	}

	// 构建完整URL路径
	function buildUrl(path) {
		return path ? path + '/' : '';
	}

	// 更新面包屑导航
	function updateBreadcrumbs() {
		const breadcrumb = document.getElementById('breadcrumb');
		// 清空当前面包屑
		breadcrumb.innerHTML = '<a href="#" onclick="navigate(\'\'); return false;">根目录</a>';

		// 如果当前不是根目录，则显示路径
		if (currentPath) {
			const parts = currentPath.split('/');
			let cumulativePath = '';

			for (let i = 0; i < parts.length; i++) {
				if (parts[i]) {
					cumulativePath += (cumulativePath ? '/' : '') + parts[i];
					breadcrumb.innerHTML += ' / <a href="#" onclick="navigate(\'' + cumulativePath + '\'); return false;">' + parts[i] + '</a>';
				}
			}
		}
	}

	// 列出目录内容
	function listDirectory(path) {
		const contentDiv = document.getElementById('content');
		contentDiv.innerHTML = '<div class="loading">加载中...</div>';

		// 构建基于相对路径的URL
		const baseUrl = buildUrl(path);

		// 使用fetch API获取目录列表
		fetch(baseUrl)
			.then(response => {
				if (!response.ok) {
					throw new Error(`HTTP error! Status: ${response.status}`);
				}
				return response.text();
			})
			.then(html => {
				// 解析HTML来提取目录和文件
				const parser = new DOMParser();
				const doc = parser.parseFromString(html, 'text/html');
				const links = Array.from(doc.querySelectorAll('a'));

				console.log("Found links:", links.length);

				// 过滤目录链接
				const items = links.filter(a => {
					const href = a.getAttribute('href');
					// 输出调试信息
					console.log("Link:", href, a.textContent);

					// 排除不是文件或目录的链接
					if (!href || href === './' || href === 'index.html' ||
					    href.startsWith('?') || href.startsWith('http')) {
						return false;
					}

					// 如果是根目录，则排除上级目录链接
					return !(href === '../' && !currentPath);


				});

				console.log("Filtered items:", items.length);

				// 创建统一的数据结构
				const fileList = [];

				// 如果不是根目录，添加返回上级目录选项
				if (currentPath) {
					// 计算上一级目录的路径
					const parentPath = currentPath.includes('/')
						? currentPath.substring(0, currentPath.lastIndexOf('/'))
						: '';

					fileList.push({
						name: '..',
						isFolder: true,
						href: '../',
						isParent: true,
						parentPath: parentPath // 存储父目录路径，避免重复计算
					});
				}

				// 处理当前目录的内容
				items.forEach(a => {
					const href = a.getAttribute('href');
					// 忽略父目录链接，因为我们已经手动添加了
					if (href !== '../') {
						// 移除尾部斜杠来获取准确名称
						const name = a.textContent.trim().replace(/\/$/, '');
						const isFolder = href.endsWith('/');

						fileList.push({
							name: name || href.replace(/\/$/, ''), // 使用href作为备用名称
							isFolder: isFolder,
							href: href,
							isParent: false
						});
					}
				});

				console.log("Final file list:", fileList);

				if (fileList.length === 0) {
					contentDiv.innerHTML = '<p>此目录为空或无法访问。</p>';
					return;
				}

				// 排序：父目录始终在最上方，然后是文件夹，然后是文件，都按字母顺序排序
				fileList.sort((a, b) => {
					// 父目录优先
					if (a.isParent) return -1;
					if (b.isParent) return 1;

					// 文件夹优先于文件
					if (a.isFolder && !b.isFolder) return -1;
					if (!a.isFolder && b.isFolder) return 1;

					// 相同类型按名称字母顺序排序
					return a.name.localeCompare(b.name);
				});

				// 创建表格来显示内容
				let tableHTML = `
                    <table>
                        <thead>
                            <tr>
                                <th>名称</th>
                                <th>最后修改时间</th>
                                <th>大小</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

				// 统一处理所有条目
				fileList.forEach(item => {
					if (item.isFolder) {
						if (item.isParent) {
							// 处理返回上级目录，使用已存储的 parentPath
							tableHTML += `
                                <tr>
                                    <td><a href="#" class="folder" onclick="navigate('${item.parentPath}'); return false;">返回上级目录</a></td>
                                    <td>-</td>
                                    <td>-</td>
                                </tr>
                            `;
						} else {
							// 处理普通文件夹
							const itemPath = currentPath
								? `${currentPath}/${item.name}`
								: item.name;

							tableHTML += `
                                <tr>
                                    <td><a href="#" class="folder" onclick="navigate('${itemPath}'); return false;">${item.name}</a></td>
                                    <td>-</td>
                                    <td>-</td>
                                </tr>
                            `;
						}
					} else {
						// 处理文件
						tableHTML += `
                            <tr>
                                <td><a href="${baseUrl}${item.href}" class="file" target="_blank">${item.name}</a></td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                        `;
					}
				});

				tableHTML += '</tbody></table>';
				contentDiv.innerHTML = tableHTML;
			})
			.catch(error => {
				contentDiv.innerHTML = `<p>加载错误: ${error.message}</p><p>请确保服务器已启动并支持目录浏览。</p>`;
				console.error("Fetch error:", error);
			});
	}
</script>
</body>
</html>
