<!DOCTYPE html>
<html lang="zh-CN">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Maven 仓库浏览器</title>
	<style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            border-bottom: 1px solid #eaecef;
            padding-bottom: 0.3em;
        }

        .breadcrumb {
            margin-bottom: 20px;
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
        }

        .breadcrumb a {
            text-decoration: none;
            color: #0366d6;
            margin: 0 5px;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            text-align: left;
            padding: 8px;
            background-color: #f8f9fa;
            border-bottom: 2px solid #dfe2e5;
        }

        td {
            padding: 8px;
            border-bottom: 1px solid #dfe2e5;
        }

        tr:hover {
            background-color: #f6f8fa;
        }

        .folder {
            font-weight: bold;
            color: #0366d6;
        }

        .file {
            color: #24292e;
        }

        .folder:before {
            content: "📁 ";
        }

        .file:before {
            content: "📄 ";
        }

        .loading {
            text-align: center;
            font-size: 1.2em;
            margin: 40px;
        }
	</style>
</head>
<body>
<h1>Maven 仓库浏览器</h1>
<div id="breadcrumb" class="breadcrumb">
	<!-- 面包屑导航将由JavaScript动态生成 -->
</div>
<div id="content">
	<div class="loading">加载中...</div>
</div>

<script>
	// 全局变量，存储当前路径
	let currentPath = '';

	// 页面加载完成后执行
	window.onload = function () {
		// 获取并处理URL中的路径参数
		const urlParams = new URLSearchParams(window.location.search);
		const path = urlParams.get('path') || '';
		navigate(path);

		// 添加浏览器历史导航支持
		window.onpopstate = function (event) {
			if (event.state && event.state.path !== undefined) {
				navigateWithoutHistory(event.state.path);
			} else {
				navigateWithoutHistory('');
			}
		};
	};

	// 导航到指定路径 - 添加到浏览器历史
	function navigate(path) {
		// 规范化路径格式
		path = normalizePath(path);
		history.pushState({path: path}, '', path ? `?path=${encodeURIComponent(path)}` : '');
		navigateWithoutHistory(path);
	}

	// 不修改浏览历史的导航函数
	function navigateWithoutHistory(path) {
		// 规范化路径格式
		path = normalizePath(path);
		currentPath = path;
		updateBreadcrumbs();
		listDirectory(path);
	}

	// 规范化路径格式，确保路径格式一致
	function normalizePath(path) {
		// 移除开头和结尾的斜杠
		path = path.replace(/^\/+|\/+$/g, '');
		// 统一处理多个连续斜杠为单个斜杠
		path = path.replace(/\/+/g, '/');
		return path;
	}

	// 构建完整URL路径
	function buildUrl(path) {
		return path ? path + '/' : '';
	}

	// 更新面包屑导航
	function updateBreadcrumbs() {
		const breadcrumb = document.getElementById('breadcrumb');
		// 清空当前面包屑
		breadcrumb.innerHTML = '<a href="#" onclick="navigate(\'\'); return false;">根目录</a>';

		// 如果当前不是根目录，则显示路径
		if (currentPath) {
			const parts = currentPath.split('/');
			let cumulativePath = '';

			for (let i = 0; i < parts.length; i++) {
				if (parts[i]) {
					cumulativePath += (cumulativePath ? '/' : '') + parts[i];
					breadcrumb.innerHTML += ' / <a href="#" onclick="navigate(\'' + cumulativePath + '\'); return false;">' + parts[i] + '</a>';
				}
			}
		}
	}

	// 列出目录内容
	function listDirectory(path) {
		const contentDiv = document.getElementById('content');
		contentDiv.innerHTML = '<div class="loading">加载中...</div>';

		// 构建基于相对路径的URL
		const baseUrl = buildUrl(path);

		// 使用fetch API获取目录列表
		fetch(baseUrl)
			.then(response => response.text())
			.then(html => {
				// 解析HTML来提取目录和文件
				const parser = new DOMParser();
				const doc = parser.parseFromString(html, 'text/html');
				const links = Array.from(doc.querySelectorAll('a'));

				// 过滤掉父目录链接和其他非文件/文件夹项
				const items = links.filter(a => {
					const href = a.getAttribute('href');
					return href !== './' && href !== 'index.html' && !href.startsWith('?') && !href.startsWith('http');
				});

				// 创建统一的数据结构
				const fileList = [];

				// 如果不是根目录，添加返回上级目录选项
				if (currentPath) {
					// 计算上一级目录的路径
					const parentPath = currentPath.includes('/')
						? currentPath.substring(0, currentPath.lastIndexOf('/'))
						: '';

					fileList.push({
						name: '..',
						isFolder: true,
						href: '../',
						isParent: true,
						parentPath: parentPath // 存储父目录路径，避免重复计算
					});
				}

				// 处理当前目录的内容
				items.forEach(a => {
					const href = a.getAttribute('href');
					// 忽略父目录链接，因为我们已经手动添加了
					if (href !== '../') {
						const name = a.textContent.replace('/', '');
						const isFolder = href.endsWith('/');

						fileList.push({
							name: name,
							isFolder: isFolder,
							href: href,
							isParent: false
						});
					}
				});

				if (fileList.length === 0) {
					contentDiv.innerHTML = '<p>此目录为空或无法访问。</p>';
					return;
				}

				// 排序：父目录始终在最上方，然后是文件夹，然后是文件，都按字母顺序排序
				fileList.sort((a, b) => {
					// 父目录优先
					if (a.isParent) return -1;
					if (b.isParent) return 1;

					// 文件夹优先于文件
					if (a.isFolder && !b.isFolder) return -1;
					if (!a.isFolder && b.isFolder) return 1;

					// 相同类型按名称字母顺序排序
					return a.name.localeCompare(b.name);
				});

				// 创建表格来显示内容
				let tableHTML = `
                    <table>
                        <thead>
                            <tr>
                                <th>名称</th>
                                <th>最后修改时间</th>
                                <th>大小</th>
                            </tr>
                        </thead>
                        <tbody>
                `;

				// 统一处理所有条目
				fileList.forEach(item => {
					if (item.isFolder) {
						if (item.isParent) {
							// 处理返回上级目录，使用已存储的 parentPath
							tableHTML += `
                                <tr>
                                    <td><a href="#" class="folder" onclick="navigate('${item.parentPath}'); return false;">返回上级目录</a></td>
                                    <td>-</td>
                                    <td>-</td>
                                </tr>
                            `;
						} else {
							// 处理普通文件夹
							const itemPath = currentPath
								? `${currentPath}/${item.name}`
								: item.name;

							tableHTML += `
                                <tr>
                                    <td><a href="#" class="folder" onclick="navigate('${itemPath}'); return false;">${item.name}</a></td>
                                    <td>-</td>
                                    <td>-</td>
                                </tr>
                            `;
						}
					} else {
						// 处理文件
						tableHTML += `
                            <tr>
                                <td><a href="${baseUrl}${item.href}" class="file" target="_blank">${item.name}</a></td>
                                <td>-</td>
                                <td>-</td>
                            </tr>
                        `;
					}
				});

				tableHTML += '</tbody></table>';
				contentDiv.innerHTML = tableHTML;
			})
			.catch(error => {
				contentDiv.innerHTML = `<p>加载错误: ${error.message}</p>`;
			});
	}
</script>
</body>
</html>
